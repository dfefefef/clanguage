/*
	void *malloc(size_t _size);在堆中从低地址往高地址查询直到找到满足空间要求的连续内存空间，返回该空间的首地址
	void *calloc(int n, size_t _size);同malloc，同时将堆中动态分配的内存初始化为零
	void *realloc(void * _ptr, size_t _size);根据size的大小重新分配ptr指向的地址空间
		如果size变小realloc只是改变索引信息
		如果size变大
			1.如果当前的空间后面有足够的内存空间，则在当前空间后面扩展空间，并返回当前指针
			2.如果当前内存空间后面没有足够的内存空间，则在堆中重新分配指定大小的空间，并将当前空间的值复制到新空间当中
			并返回新空间的首地址，将原空间释放。（这种情况指针ptr会变成野指针，应该先保存ptr的值）
		申请失败返回NULL


	void free(void *p);释放p指向的动态分配的存储区，而后p就会变成“野指针”，此时p仍可以对指向的区域进行操作，
		所以，在free指针的指向区域过后，应该将p=null置空，防止野指针访问到其他数据。

	内存泄漏
		1.分配内存后没有回收内存，
		2.分配内存后指针丢失

*/

#include<stdlib.h>

