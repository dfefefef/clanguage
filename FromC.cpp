/*
	引用：&
		定义一个引用时候，引用一定要初始化为一个变量；只能引用变量，不能引用常量和表达式
		引用只能被初始化一次，当引用被初始化后就一直引用该变量，不能再次引用其他变量（从一而终）；
		引用可以传递；

		常引用：CONST T &N，引用不能用来修改指定变量的值
		CONST T & 和T & 是不同类型，CONST T型和CONST T &类型的引用不能用来初始化T &类型

	引用和指针
		



	CONST
		用CONST定义常量便于类型检查
		
		常量指针CONST T * P：不能通过P去修改P指向的内容，可以通过其他方式修改；常量指针的意思不是只能不能修改，
		常量指针可以再次指向其他位置。

		指针可以赋值给常量指针，反过来不可以，除非强转（T *）

	内存动态分配
		NEW T、NEW T[N]动态分配一定的空间并返回（一片）空间的（首）地址类型为 T *；
		动态分配的空间一定需要DELETE释放，DELETE NEW出来的空间指针，而且一片空间不能被DELETE超过一次
		DELETE []P; 释放P指向的数组空间



	内联函数
		用INLINE声明，在编译阶段直接在函数调用处实现函数功能，即插入函数，节省函数多次调用产生的出入栈开销；
		适合用在函数运行开销和调用函数出入栈开销相近的情况；



	函数重载
		只有函数返回值不同的情况不是函数重载；



	函数参数表中参数值缺省
		VOID FUN(INT A， INT B = 3, INT  C = 2);调用的时候FUN(2,,8);不允许，只能最右边的连续若干个参数缺省
		缺省的设置可以提高程序的扩充性，当需要添加函数参数的时候，可以在不修改已调用函数的代码的情况下添加函数参数
		原来已经调用函数的代码用保持缺省



*/
#include<iostream>

int n = 0;

int *setvalue()
{
	return &n;
}

void SetValue()
{
	std::cout << "before setvalue n=" << n << std::endl;
	*setvalue() = 2;
	std::cout << "after setvalue n=" << n << std::endl;
}