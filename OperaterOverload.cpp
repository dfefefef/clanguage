/*

运算符重载：运算符重载实际上就是函数重载
	
	成员运算符重载
		赋值运算符"="只能重载为成员函数，运算符重载为成员函数要比重载为全局函数少一个运算目

	全局运算符重载
		同上

	赋值运算符重载
		考虑到原生的赋值"="运算符在在赋值的时候是使左边的对象的内容等于右边对象的内容，所以这种赋值方式在某些情形下有危险；
		即深拷贝和浅拷贝的问题，在对象是指针的情况下，如果只是使得指针内容相同，那么就会出现浅拷贝的问题。这个时候应该重载
		赋值运算符解决浅拷贝的问题，采用深拷贝的方法，给被赋值的对象指向的内容分配新的空间。赋值运算符的重载函数返回值返回
		引用来保持原生赋值运算符表达式等价于左边对象的运算符特性。
		同时，注意默认拷贝构造函数也会出现这种问题，默认拷贝构造函数也只是浅拷贝。

	可变长数组实现
	{
		关键：赋值运算符实现，拷贝构造函数实现，[]运算符重载，push_back()函数实现（动态数组的关键）		
		
		push_back()在已经分配好的内存空间内进行动态数组的增长:
			new (p)T(value),将T类构造的成员值为value的对象放入p指针后面，即placement new

		
	}

	类型转换运算符重载
		operater Type(){};类型转换运算符重载的时候，不需要返回值类型，即Type类型本身就是一个返回值的类型
		类型转换运算符可以被隐式的调用，即在与不同类型的对象做运算操作时，可以隐式调用类型转换运算符


	自增自减运算符重载
		前置自增自减运算符重载，参数表比后置的后一个，重载为类的成员函数时没有参数，重载为全局函数时候包含
		一个（自己）运算符。
		后置自增自减运算符重载，说明如上，多一个无用的参数int，在函数体中并不使用，只是用于区别前置与后置


	运算符重载注意事项：
		1.运算符重载不改变运算符的优先级；
		2.".",".*","::","?:",sizeof这些运算符不能被重载；
		3.重载(),[],->,=这些运算符时，需要重载为成员函数。

*/