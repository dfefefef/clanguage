/*
class A:public B
{};

派生对象的体积
	派生对象等于基类对象的体积加上派生对象增加的成员变量的体积，而且基类对象的成员的存储位置位于派生类新增成员之前

	覆盖：派生类与基类同名的函数将基类的函数覆盖，即默认调用派生类的函数，除非指定为基类的函数Base::，
	protected声明，即在private的基础上多出了给子类访问的权限，不能被类外直接访问，专门为派生机制设置的。

派生的关系和复合关系
	一个派生类同时也是一个基类
	关于复合关系，要注意派生关系的运用，不要将不具有派生关系的类之间用派生定义
	例如point和circle类之间的关系，是一种复合关系而不是派生关系，在逻辑上一定要行得通

派生类的构造函数
	派生类的构造函数，在初始化基类的成员的时候需要调用基类的构造函数（在初始化列表当中），如果不显示地调用初始化列表
	将调用基类的无参构造函数（没有则出错），先调用基类的构造函数初始化基类成员再调用派生类的构造函数，析构的时候相反

	封装类的构造函数执行顺序为先执行基类的构造函数，再执行成员类的构造函数，最后执行封装类的构造函数，析构函数顺序相反

共有（public）派生的赋值兼容
	共有派生类对象可以直接赋值给基类对象，共有派生类的对象可以赋给基类对象的引用和指针，反过来不行（和基类派生类成员在
	地址中排列顺序有关），此外private和protected派生的类不满足以上规则。

间接基类和直接基类
	...


*/